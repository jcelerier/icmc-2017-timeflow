\documentclass{article}

\usepackage{icmc2017template}
\usepackage{times}
\usepackage{ifpdf}
\usepackage{soul}
\usepackage{microtype}
\usepackage{polyglossia}
%\usepackage{geometry}
\usepackage{tikz}
\usepackage{listings}

\def\papertitle{Paper Template for ICMC 2017}
\def\firstauthor{First Author}
\def\secondauthor{Second Author}
\def\thirdauthor{Third Author}
\def\fourthauthor{Fourth Author}
\def\fifthauthor{Fifth Author}
\def\sixthauthor{Sixth Author}

\threeauthors
{0.5in}
{\firstauthor} {Affiliation1 \\ %
    {\tt \href{mailto:author1@smcnetwork.org}{author1@smcnetwork.org}}}
{\secondauthor} {Affiliation2 \\ %
    {\tt \href{mailto:author2@smcnetwork.org}{author2@smcnetwork.org}}}
{\thirdauthor} { Affiliation3 \\ %
    {\tt \href{mailto:author3@smcnetwork.org}{author3@smcnetwork.org}}}


\usepackage[
pdftitle={\papertitle},
pdfauthor={\firstauthor, \secondauthor, \thirdauthor},
bookmarksnumbered, % use section numbers with bookmarks
pdfstartview=XYZ % start with zoom=100% instead of full screen; 
% especially useful if working with a big screen :-)
]{hyperref}
%\pdfcompresslevel=9

\usepackage{graphicx}
\DeclareGraphicsExtensions{.pdf,.jpeg,.png}

\usepackage[figure,table]{hypcap}


\hypersetup{
    colorlinks,%
    citecolor=black,%
    filecolor=black,%
    linkcolor=black,%
    urlcolor=black
}

\title{Temporal dataflow graphs and their application to generative music}

\begin{document}
    
    \capstartfalse
    \maketitle
    \capstarttrue
    
	\section{Introduction}
    This work explores the association of temporal semantics to standard data flow graphs used in music and signal processing.
    
    We analyze the meanings that can be given to a graphical representation of processes executing in time. 
    
    For instance, given two processes $p_1, p_2$, what can be said of a program where $p_1$ executes from $t=0$ to $t=5$ seconds, and $p_2$ from $t=3$ to $t=6$ when $p_1$ and $p_2$ operate on the same data.
    
    An example would be an audio filter: $p_1$ is a low-pass and $p_2$ a reverb.
    
    The simplest strategy can be to only allow execution when all processes are active and have been given a definite order of execution: in this case the processes will only execute from $t=3$ to $t=5$ and behave like function composition. 
    While safe from the point of view of software execution, we will show that other execution policies leveraging information from the temporal layout of the processes can provide composers with new creative capabilities.
    
    The main problem that arises is that composers may specify relationships between processes, but such processes may not always be active. 
    We start by making the case for an environment associated with the dataflow graph that contains the values of the inputs and outputs.
    Then, since a graph may not always be fully active, we show that it is also meaningful to have implicit connections between nodes of the graph, that will use the environment.
    This allows dynamic routing of the processes according to their temporal order during execution, and extends routing to pattern-matched elements of the environment instead of single values.
    We enumerate four different behaviours regarding the input and output parameters when the nodes are implicitely connected at runtime using the environment: strict, glutton, parallelized, and replaced. 
    Additionnaly, when the node are explicitely connected, we introduce a delay mechanism that allows a computation to happen on data previously produced by another node of the graph.
    \subsection{Related works}
    Citer Kyma
    Céu
    Perl
    
    \subsection{Examples}
    
    \subsection{Temporal formalism}
    Rappel i-score / ossia
    
    
	\section{Graph definitions}
    We rely on two families of graphs for the execution of the software: 
    \begin{itemize}
        \item A dataflow graph between processes: processes have input and output ports that can be connected together to enforce data dependencies.
        \item A temporal graph, based on the OSSIA formalism: $G_t(V_t, E_t)$ where $V_t$ is the set of time nodes and $E_t$ is the set of time constraints in a score.
    \end{itemize}
    There may be more than a single temporal graph: they can be arranged hierarchically.
    
    The execution is driven by a scheduler. 
    
    At each tick, the state of each temporal graph is updated with the following informations: 
    \begin{itemize}
        \item Which processes are currently running.
        \item For how long these processes have been running.
    \end{itemize}

    This is done according to the various events that occur and may trigger conditions and interaction points present in the temporal score.
    
    Event-driven vs time-driven vs sound-driven ; each node has a "driver" port which is the time or the sound. (Do like LV2: pass empty buffers). Pb: multi-rate ... voir méthode pour passer de multi-rate à single rate dans PLOP2006 et Signal Flow Graphs and Data Flow Graphs (3.2, 3.3), dans Handbook of Signal Processing (First Edition)
    
    % Pour thèse: essayer de spécifier l'ensemble des cas possible / configuraitons d'activation de manière statique à partir d'un scénario donné, même si c'est exponentiel..

	%\subsection{Why multiple graphs ?}
	%\subsection{Hierarchy}
    
    Throughout this paper, we will use the execution traces in fig.~\ref{fig.simple} and fig.~\ref{fig.simple-reversed} as running example. 
    \begin{figure}
        \centering
        \begin{tikzpicture}[scale=0.5]
        \draw[line width=2pt] (0, 0) -- (0, 2) -- (5, 2) -- (5, 0) -- (0, 0);
        \draw[line width=2pt] (0 + 3, 0 - 2.5) -- (0 + 3, 2 - 2.5) -- (5 + 3, 2 - 2.5) -- (5 + 3, 0 - 2.5) -- (0 + 3, 0 - 2.5);
        
        \draw[line width=2pt] 
        (0, -3.75) -- 
        (0, -4) -- (3, -4) -- 
        (3, -3.75) --
        (3, -4) -- (5, -4) -- 
        (5, -3.75) -- 
        (5, -4) -- (8, -4) -- 
        (8, -3.75);
        
        \node (t1) at (1.45, -3.45) {\large $t_1$};
        \node (t2) at (4, -3.45) {\large $t_2$};
        \node (t3) at (6.5, -3.45) {\large $t_3$};
        
        \node (f1) at (2.5, 1) {\large $f_1$} ;
        \node (f2) at (5.5, -1.5) {\large $f_2$} ;
        \end{tikzpicture}
        \caption{A possible trace of execution for two processes}
        \label{fig.simple}
    \end{figure}
	
    \begin{figure}[h]
        \centering
        \begin{tikzpicture}[scale=0.5]
        \draw[line width=2pt] (0 + 3, 0) -- (0 + 3, 2) -- (5 + 3, 2) -- (5 + 3, 0) -- (0 + 3, 0);
        \draw[line width=2pt] (0, 0 - 2.5) -- (0, 2 - 2.5) -- (5, 2 - 2.5) -- (5, 0 - 2.5) -- (0, 0 - 2.5);
        
        \draw[line width=2pt] 
        (0, -3.75) -- 
        (0, -4) -- (3, -4) -- 
        (3, -3.75) --
        (3, -4) -- (5, -4) -- 
        (5, -3.75) -- 
        (5, -4) -- (8, -4) -- 
        (8, -3.75);
        
        \node (t1) at (1.45, -3.45) {\large $t_1$};
        \node (t2) at (4, -3.45) {\large $t_2$};
        \node (t3) at (6.5, -3.45) {\large $t_3$};
        
        \node (f1) at (5.5, 1) {\large $f_1$} ;
        \node (f2) at (2.5, -1.5) {\large $f_2$} ;
        \end{tikzpicture}
        \caption{Another trace of execution with the same processes}
        \label{fig.simple-reversed}
    \end{figure}
    
	\section{Environment, implicit and explicit connections}
    In the traditional data flow paradigm, nodes are linked together through connections in their respective input and output ports.
    
    We extend this with a permanent environment, that contains a mapping of key-value pairs. 
    Keys are adresses: \lstinline|/foo/bar| and values can be any kind of data: numbers, strings, etc. 
    The values of the environment may vary independently of the execution of the program: for instance elements of the environment could be changed through the network, graphical or physical controls.
    
    We then have to provide a mean to use the values of this environment to the dataflow graph.
    Thus, we extend the inputs and outputs ports with the following expliciteness semantic: 
    
    \begin{itemize}
        \item An explicit port has been connected by the developer to another port.
        \item An implicit port has not been connected to another port but may accept any number of adress - value pairs from the environment to perform its work.
    \end{itemize}
    
    During a tick, adresses have access to two sets of values: 
    \begin{itemize}
        \item The values that were in the environment at the beginning of the tick.
        \item The values produced by previous nodes in the graph.
    \end{itemize}

    It is up to the developer of nodes of the graph to choose whether a port can only work when connected explicitely, or with the environment produced from previous nodes, or with the global environment, or both.

    This mechanism allows for new patterns during the creation of a dataflow program: for instance, instead of accepting data from a single source, a port could specify a pattern (see OSC 1.1 paper with XPath) such as: \lstinline|/foo.*/bar/b[a-zA-Z]|. 
    % TODO pattern-matched addresses on the output: seems hard ? how to match it with a "pattern-matched" input port ??
	%Inner data: reduces the possibilities of connection: everything has to be there (explicit)
	
	%Outer data: have to care about overwriting (implicit)
    %Implicit edges allow for features such as pattern-matching: one node outputs to random, unknown other inputs, or to the global state.
    % For inputs to handle this, we have to provide them with a "can accept" function.
	
    
    % TODO sample-precision of the activation / deactivation of a process / node
    % TODO 
	\section{Relationships}
    We are interested in the relationships between nodes of the dataflow graph when they produce compatible tokens.
     
     NOTE : if we have cables  we shouldn't have the "parameters" spill to other nodes. 
    \subsection{Strict}
    An execution of a sub-graph can only happen when all the nodes of the sub-graph are executing.
    
    That is, if two nodes are compatible, the output of the first node can only go in the input of the second node when both are active.
    
    For instance, take the case in fig.~\ref{fig.simple} where $f_1$ and $f_2$ both read from $/a$ and write to $/a$.
    
    Let $t$ be the time of the tick and $e$ the global environment. We assume that $f_1, f_2$ always have access to this information.
    
    We will get the following set of equations representing the behaviour: 
    \begin{itemize}
        \item During $t_0$: $\emptyset$.
        \item During $t_1$: $f_2 \circ f_1 $ or $f_1 \circ f_2$.
        \item During $t_2$: $\emptyset$. 
    \end{itemize}

    The strict execution may happen explicitely or implicitely.
    
	\subsection{Glutton}
	An execution of a sub-graph can happen whenever any of the nodes of a sub-graph are executing. 
    
    If we take the same case than previously, the behaviour is:
    \begin{itemize}
        \item $t_0$: $f_1$.
        \item $t_1$: $f_2 \circ f_1$ or $f_1 \circ f_2$.
        \item $t_2$: $f_2$. 
    \end{itemize}

    The glutton execution may happen explicitely or implicitely.
    
	\subsection{Delayed}
	A connection between an output and an input is delayed through bufferisation in a queue.
	
	The bufferisation can behave in two way:
	\begin{itemize}
		\item Readers of the buffer always start from the same point (the beginning of the previous function in the callback chain).
		\item Readers of the buffer continue from the latest read position.
		Question: what happens in case of multiple read ?
	\end{itemize}
	
    Note: this question has an answer in PLOP2006.
    
    The delayed execution has be specified explicitely for the tokens to be bufferised.
    
    If we have a delay connection from $f_1$ to $f_2$, the first call to $f_2$ will use the first value that was produced by $f_1$, and nothing before.
	
	\subsection{Parallelized and mixed}
	All the sub-graphs are run with the same input environment. 
	The resulting values put in the environment are undefined, but it is guaranteed that all values returned will have been set, which may trigger event handlers.
    
    For audio or video streams however, a meaningful behaviour would be to mix all the outputs together.
    
    Thus, we have to define summing operations for each of the data types supported.
    
    We propose for instance: 
    \begin{itemize}
        \item For simple parameters such as MIDI control changes or OSC messages: the latest value replaces the previous ones.
        \item For audio streams: the streams are mixed together.
        \item For MIDI notes: the notes are played together.
    \end{itemize}

    The parallelized execution may happen explicitely or implicitely.

    \begin{itemize}
        \item $t_0$: $f_1$.
        \item $t_1$: $f_1$ and $f_2$ run in parallel, with the same value for $/a$.
        \item $t_2$: $f_2$. 
    \end{itemize}
     
	\subsection{Replaced}
	All the nodes are run with the same input environment. 
	The resulting values put in the environment are those of the latest graph execution.
	 
    \begin{itemize}
        \item $t_0$: $f_1$.
        \item $t_1$: $f_1$ or $f_2$.
        \item $t_2$: $f_2$. 
    \end{itemize}

    The replaced execution may happen explicitely or implicitely.
    
    \section{Where to put the relationships}
    \subsection{In the cables}
    \subsection{In the ports}
    \subsection{In the nodes}
    \subsection{In the addresses}
    No temporal behaviour possible
    \subsection{Global behaviour}
    No temporal behaviour possible
    \subsection{Overall resolution}
    Unspecified by default. 
    
    Hierarchical: cable, port, node, address, global.
    
    Default global behaviour: glutton.
    
  
    \section{Default behaviours for orders}
    We study here the various behaviours possible to handle the dependency between nodes of the graph. 
    We can for instance leverage information provided in the temporal graph to connect the nodes at runtime. 
    
    \subsection{Manual ordering}
    The user explicitely draws a cable between two ports.
    
    \subsection{Hierarchical}
    We follow the hierarchical organization of the temporal graph~: each time constraint has an ordered list of processes, and each time constraint is itself ordered in the scenario. This gives an order between processes.
    
    \subsection{Temporal}
    If no order is given, the temporal order in which objects are executed
    will become the order of chaining in the call graph.
    
    That is, if the execution happens in the order of the fig.~\ref{fig.simple}, we get the following execution: 
    
    \begin{itemize}
        \item $t_0$: $f_1$.
        \item $t_1$: $f_2 \circ f_1$.
        \item $t_2$: $f_2$. 
    \end{itemize}

    Instead, if we are in the case of fig.~\ref{fig.simple-reversed}, we get for $t_1$ the execution $f_1 \circ f_2$.
    
	\section{Evaluation algorithm}
    We present here the evaluation algorithm that operates at each tick.
    
    
	Divide the time in abstract segment according to the activation graph; gives us a set of equations for each variable.
	\section{Implementation}
    \section{Conclusion}
    Additional consideration: see PLOP 2006 article (multi-stream, etc), sample accuracy, etc
    
    Explicit cables: optimization.
\end{document}