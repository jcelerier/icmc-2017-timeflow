\documentclass{article}

\usepackage{icmc2017template}
\usepackage{times}
\usepackage{ifpdf}
\usepackage{soul}
\usepackage{microtype}
\usepackage{polyglossia}
%\usepackage{geometry}

\def\papertitle{Paper Template for ICMC 2017}
\def\firstauthor{First Author}
\def\secondauthor{Second Author}
\def\thirdauthor{Third Author}
\def\fourthauthor{Fourth Author}
\def\fifthauthor{Fifth Author}
\def\sixthauthor{Sixth Author}

\threeauthors
{0.5in}
{\firstauthor} {Affiliation1 \\ %
    {\tt \href{mailto:author1@smcnetwork.org}{author1@smcnetwork.org}}}
{\secondauthor} {Affiliation2 \\ %
    {\tt \href{mailto:author2@smcnetwork.org}{author2@smcnetwork.org}}}
{\thirdauthor} { Affiliation3 \\ %
    {\tt \href{mailto:author3@smcnetwork.org}{author3@smcnetwork.org}}}


\usepackage[
pdftitle={\papertitle},
pdfauthor={\firstauthor, \secondauthor, \thirdauthor},
bookmarksnumbered, % use section numbers with bookmarks
pdfstartview=XYZ % start with zoom=100% instead of full screen; 
% especially useful if working with a big screen :-)
]{hyperref}
%\pdfcompresslevel=9

\usepackage{graphicx}
\DeclareGraphicsExtensions{.pdf,.jpeg,.png}

\usepackage[figure,table]{hypcap}


\hypersetup{
    colorlinks,%
    citecolor=black,%
    filecolor=black,%
    linkcolor=black,%
    urlcolor=black
}

\title{Temporal dataflow graphs and their application to generative music}

\begin{document}
    
    \capstartfalse
    \maketitle
    \capstarttrue
    
	\section{Introduction}
    This work explores the association of temporal semantics to standard data flow graphs used in music and signal processing.
    
    We analyze the meanings that can be given to a graphical representation of processes executing in time. 
    
    For instance, given two processes $p_1, p_2$, what can be said of a program where $p_1$ executes from $t=0$ to $t=5$ seconds, and $p_2$ from $t=3$ to $t=6$ when $p_1$ and $p_2$ operate on the same data.
    
    An example would be an audio filter : $p_1$ is a low-pass and $p_2$ a reverb.
    
    The simplest strategy can be to only allow execution when all processes are active and have been given a definite order of execution : in this case the processes will only execute from $t=3$ to $t=5$ and behave like function composition. 
    While safe from the point of view of software execution, we will show that other execution policies leveraging information from the temporal layout of the processes can provide composers with new creative capabilities.
    
    The main problem that arises is that composers may specify relationships between processes, but such processes may not always be active. 
    We start by making the case for an environment associated with the dataflow graph that contains the values of the inputs and outputs.
    Then, since a graph may not always be fully active, we show that it is also meaningful to have implicit connections between nodes of the graph, that will use the environment.
    This allows dynamic routing of the processes according to their temporal order during execution, and extends routing to pattern-matched elements of the environment instead of single values.
    We enumerate four different behaviours regarding the input and output parameters when the nodes are implicitely connected at runtime using the environment : strict, glutton, parallelized, and replaced. 
    Additionnaly, when the node are explicitely connected, we introduce a delay mechanism that allows a computation to happen on data previously produced by another node of the graph.
    \subsection{Related works}
    Citer Kyma
    Céu
    Perl
    
    \subsection{Examples}
    
    \subsection{Temporal formalism}
    Rappel i-score / ossia
    
    
	\section{Graph definitions}
    We rely on two families of graphs for the execution of the software : 
    \begin{itemize}
        \item A dataflow graph between processes : processes have input and output ports that can be connected together to enforce data dependencies.
        \item A temporal graph, based on the OSSIA formalism: $G_t(V_t, E_t)$ where $V_t$ is the set of time nodes and $E_t$ is the set of time constraints in a score.
    \end{itemize}
    There may be more than a single temporal graph : they can be arranged hierarchically.
    
    The execution is driven by a scheduler. 
    
    At each tick, the state of each temporal graph is updated with the following informations : 
    \begin{itemize}
        \item Which processes are currently running.
        \item For how long these processes have been running.
    \end{itemize}

    This is done according to the various events that occur and may trigger conditions and interaction points present in the temporal score.
    
    Event-driven vs time-driven vs sound-driven ; each node has a "driver" port which is the time or the sound. (Do like LV2 : pass empty buffers). Pb : multi-rate ... voir méthode pour passer de multi-rate à single rate dans PLOP2006 et Signal Flow Graphs and Data Flow Graphs (3.2, 3.3), dans Handbook of Signal Processing (First Edition)
    
    % Pour thèse : essayer de spécifier l'ensemble des cas possible / configuraitons d'activation de manière statique à partir d'un scénario donné, même si c'est exponentiel..

	%\subsection{Why multiple graphs ?}
	%\subsection{Hierarchy}
	
	\section{Implicit and explicit connections}
	Inner data : reduces the possibilities of connection : everything has to be there (explicit)
	
	Outer data : have to care about overwriting (implicit)
    Implicit edges allow for features such as pattern-matching : one node outputs to random, unknown other inputs, or to 
    the global state.
    For inputs to handle this, we have to provide them with a "can accept" function.
	
    
	\section{Relationships}
    \subsection{Strict}
    An execution of a sub-graph can only happen when all the nodes of the sub-graph are executing.
    
	\subsection{Glutton}
	An execution of a sub-graph can happen whenever any of the nodes of a sub-graph are executing. 
	An order has to be provided.
    
    
	\subsection{Delayed}
	A connection between an output and an input is delayed through bufferisation in a queue.
	
	The bufferisation can behave in two way :
	\begin{itemize}
		\item Readers of the buffer always start from the same point (the beginning of the previous function in the callback chain).
		\item Readers of the buffer continue from the latest read position.
		Question : what happens in case of multiple read ?
	\end{itemize}
	
	
	\subsection{Parallelized}
	All the sub-graphs are run with the same input environment. 
	The resulting values put in the environment are undefined, but it is guaranteed that all values returned will have been set.
	
    For audio or video streams however, a meaningful behaviour would be to mix all the outputs together.
     
	\subsection{Replaced}
	All the sub-graphs are run with the same input environment. 
	The resulting values put in the environment are those of the latest graph execution.
	
    
    \section{Where to put the relationships}
    \subsection{In the cables}
    \subsection{In the ports}
    \subsection{In the nodes}
    \subsection{In the addresses}
    No temporal behaviour possible
    \subsection{Global behaviour}
    No temporal behaviour possible
    \subsection{Overall resolution}
    Unspecified by default. 
    
    Hierarchical : cable, port, node, address, global.
    
    Default global behaviour : glutton.
    
    
    
    \section{Default behaviours for orders}
    The temporal graph allows to bypass a bit of cable writing.
    
    \subsection{Manual}
    The user explicitely draws a cable.
    
    \subsection{Hierarchical}
    We follow the hierarchical organization of the temporal graph.
    
    
    \subsection{Temporal glutton}
    If no order is given for the glutton case, the temporal order in which objects are executed
    will become the order of chaining in the call graph.
    
	\section{Meaning}
	Divide the time in abstract segment according to the activation graph; gives us a set of equations for each variable.
	\section{Implementation}
    \section{Conclusion}
    Additional consideration : see PLOP 2006 article (multi-stream, etc), sample accuracy, etc
    
    Explicit cables : optimization.
\end{document}